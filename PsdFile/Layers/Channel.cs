/////////////////////////////////////////////////////////////////////////////////
//
// Photoshop PSD FileType Plugin for Paint.NET
// http://psdplugin.codeplex.com/
//
// This software is provided under the MIT License:
//   Copyright (c) 2006-2007 Frank Blumenberg
//   Copyright (c) 2010-2012 Tao Yue
//
// Portions of this file are provided under the BSD 3-clause License:
//   Copyright (c) 2006, Jonas Beckeman
//
// See LICENSE.txt for complete licensing and attribution information.
//
/////////////////////////////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Drawing;
using System.Globalization;
using System.IO;
using System.IO.Compression;
using System.Linq;

namespace PhotoshopFile
{
  public class ChannelList : List<Channel>
  {
    /// <summary>
    /// Returns channels with nonnegative IDs as an array, so that accessing
    /// a channel by Id can be optimized into pointer arithmetic rather than
    /// being implemented as a List scan.
    /// 
    /// <remarks>Note: This is crucial for blitting lots of pixels back and forth.</remarks>
    /// </summary>
    public Channel[] ToIdArray()
    {
      var maxId = this.Max(x => x.ID);
      var idArray = new Channel[maxId + 1];
      foreach (var channel in this)
      {
        if (channel.ID >= 0)
          idArray[channel.ID] = channel;
      }
      return idArray;
    }

    public ChannelList()
      : base()
    {
    }

    public Channel GetId(int id)
    {
      return this.Single(x => x.ID == id);
    }

    public bool ContainsId(int id)
    {
      return this.Exists(x => x.ID == id);
    }
  }

  ///////////////////////////////////////////////////////////////////////////

  public class Channel
  {
    private Layer m_layer;
    /// <summary>
    /// The layer to which this channel belongs
    /// </summary>
    public Layer Layer
    {
      get { return m_layer; }
    }


    private short m_id;
    /// <summary>
    /// 0 = red, 1 = green, etc.
    /// -1 = transparency mask
    /// -2 = user supplied layer mask
    /// </summary>
    public short ID
    {
      get { return m_id; }
      set { m_id = value; }
    }

    /// <summary>
    /// Total length of the channel data, including compression headers.
    /// </summary>
    public int Length { get; set; }

    private byte[] m_data;
    /// <summary>
    /// Compressed raw channel data, excluding compression headers.
    /// </summary>
    public byte[] Data
    {
      get { return m_data; }
      set { m_data = value; }
    }

    private byte[] m_imageData;
    /// <summary>
    /// The raw image data from the channel.
    /// </summary>
    public byte[] ImageData
    {
      get { return m_imageData; }
      set { m_imageData = value; }
    }

    private ImageCompression m_imageCompression;
    public ImageCompression ImageCompression
    {
      get { return m_imageCompression; }
      set { m_imageCompression = value; }
    }

    public byte[] RleHeader { get; set; }

    //////////////////////////////////////////////////////////////////

    internal Channel(short id, Layer layer)
    {
      m_id = id;
      m_layer = layer;
    }

    internal Channel(PsdBinaryReader reader, Layer layer)
    {
      Debug.WriteLine("Channel started at " + reader.BaseStream.Position.ToString(CultureInfo.InvariantCulture));
        
      m_id = reader.ReadInt16();
      Length = reader.ReadInt32();
      m_layer = layer;
    }

    internal void Save(PsdBinaryWriter writer)
    {
      Debug.WriteLine("Channel Save started at " + writer.BaseStream.Position.ToString(CultureInfo.InvariantCulture));

      writer.Write(m_id);
      writer.Write(this.Length);
    }

    //////////////////////////////////////////////////////////////////

    internal void LoadPixelData(PsdBinaryReader reader, Rectangle rect)
    {
      Debug.WriteLine("Channel.LoadPixelData started at " + reader.BaseStream.Position.ToString(CultureInfo.InvariantCulture));

      var endPosition = reader.BaseStream.Position + this.Length;
      m_imageCompression = (ImageCompression)reader.ReadInt16();
      var dataLength = this.Length - 2;

      switch (m_imageCompression)
      {
        case ImageCompression.Raw:
          m_imageData = reader.ReadBytes(dataLength);
          break;
        case ImageCompression.Rle:
          // Discard the RLE row lengths
          reader.ReadBytes(2 * rect.Height);
          var rleDataLength = dataLength - 2 * rect.Height;

          // The PSD specification states that rows are padded to even sizes.
          // However, PSD files generated by Photoshop CS4 do not actually
          // follow this stipulation.
          m_data = reader.ReadBytes(rleDataLength);
          break;
        case ImageCompression.Zip:
        case ImageCompression.ZipPrediction:
          m_data = reader.ReadBytes(dataLength);
          break;
      }

      Debug.Assert(reader.BaseStream.Position == endPosition, "Pixel data successfully read in.");
    }

    public void DecompressImageData(Rectangle rect)
    {
      var bytesPerRow = Util.BytesPerRow(rect, m_layer.PsdFile.Depth);
      var bytesTotal = rect.Height * bytesPerRow;

      if (this.ImageCompression != PhotoshopFile.ImageCompression.Raw)
      {
        m_imageData = new byte[bytesTotal];

        MemoryStream stream = new MemoryStream(m_data);
        switch (this.ImageCompression)
        {
          case PhotoshopFile.ImageCompression.Rle:
            for (int i = 0; i < rect.Height; i++)
            {
              int rowIndex = i * bytesPerRow;
              RleHelper.DecodedRow(stream, m_imageData, rowIndex, bytesPerRow);
            }
            break;

          case PhotoshopFile.ImageCompression.Zip:
          case PhotoshopFile.ImageCompression.ZipPrediction:
            // .NET implements Deflate (RFC 1951) but not zlib (RFC 1950),
            // so we have to skip the first two bytes.
            stream.ReadByte();
            stream.ReadByte();

            var deflateStream = new DeflateStream(stream, CompressionMode.Decompress);
            var bytesDecompressed = deflateStream.Read(m_imageData, 0, bytesTotal);
            Debug.Assert(bytesDecompressed == bytesTotal, "ZIP deflation output is different length than expected.");
            break;
        }
      }

      // Reverse multi-byte pixels to little-endian.  32-bit depth images
      // with ZipPrediction must be left alone because the data is a
      // byte stream.
      bool fReverseEndianness = (m_layer.PsdFile.Depth == 16)
        || (m_layer.PsdFile.Depth == 32) && (this.ImageCompression != PhotoshopFile.ImageCompression.ZipPrediction);
      if (fReverseEndianness)
        ReverseEndianness(rect);

      if (this.ImageCompression == PhotoshopFile.ImageCompression.ZipPrediction)
      {
        UnpredictImageData(rect);
      }
    }

    private void ReverseEndianness(Rectangle rect)
    {
      var byteDepth = Util.BytesFromBitDepth(m_layer.PsdFile.Depth);
      var pixelsTotal = rect.Width * rect.Height;
      if (pixelsTotal == 0)
        return;

      if (byteDepth == 2)
      {
        Util.SwapByteArray2(m_imageData, 0, pixelsTotal);
      }
      else if (byteDepth == 4)
      {
        Util.SwapByteArray4(m_imageData, 0, pixelsTotal);
      }
      else if (byteDepth > 1)
      {
        throw new Exception("Byte-swapping implemented only for 16-bit and 32-bit depths.");
      }
    }


    unsafe private void UnpredictImageData(Rectangle rect)
    {
      if (m_layer.PsdFile.Depth == 16)
      {
        fixed (byte* ptrData = &m_imageData[0])
        {
          for (int iRow = 0; iRow < rect.Height; iRow++)
          {
            UInt16* ptr = (UInt16*)(ptrData + iRow * rect.Width * 2);
            UInt16* ptrEnd = (UInt16*)(ptrData + (iRow + 1) * rect.Width * 2);

            // Start with column 1 of each row
            ptr++;
            while (ptr < ptrEnd)
            {
              *ptr = (UInt16)(*ptr + *(ptr - 1));
              ptr++;
            }
          }
        }
      }
      else if (m_layer.PsdFile.Depth == 32)
      {
        var reorderedData = new byte[m_imageData.Length];
        fixed (byte* ptrData = &m_imageData[0]) 
        {
          // Undo the prediction on the byte stream
          for (int iRow = 0; iRow < rect.Height; iRow++)
          {
            // The rows are predicted individually.
            byte* ptr = ptrData + iRow * rect.Width * 4;
            byte* ptrEnd = ptrData + (iRow + 1) * rect.Width * 4;

            // Start with column 1 of each row
            ptr++;
            while (ptr < ptrEnd)
            {
              *ptr = (byte)(*ptr + *(ptr - 1));
              ptr++;
            }
          }

          // Within each row, the individual bytes of the 32-bit words are
          // packed together, high-order bytes before low-order bytes.
          // We now unpack them into words and reverse to little-endian.
          int offset1 = rect.Width;
          int offset2 = 2 * offset1;
          int offset3 = 3 * offset1;
          fixed (byte* dstPtrData = &reorderedData[0])
          {
            for (int iRow = 0; iRow < rect.Height; iRow++)
            {
              byte* dstPtr = dstPtrData + iRow * rect.Width * 4;
              byte* dstPtrEnd = dstPtrData + (iRow + 1) * rect.Width * 4;

              byte* srcPtr = ptrData + iRow * rect.Width * 4;

              while (dstPtr < dstPtrEnd)
              {
                *(dstPtr++) = *(srcPtr + offset3);
                *(dstPtr++) = *(srcPtr + offset2);
                *(dstPtr++) = *(srcPtr + offset1);
                *(dstPtr++) = *srcPtr;

                srcPtr++;
              }
            }
          }
        }

        m_imageData = reorderedData;
      }
      else
      {
        throw new Exception("ZIP prediction is only available for 16 and 32 bit depths.");
      }
    }

    public void CompressImageData()
    {
      if (m_imageCompression == ImageCompression.Rle)
      {
        MemoryStream dataStream = new MemoryStream();
        MemoryStream headerStream = new MemoryStream();
        PsdBinaryWriter headerWriter = new PsdBinaryWriter(headerStream);

        //---------------------------------------------------------------

        short[] rleRowLengths = new short[m_layer.Rect.Height];
        int bytesPerRow = Util.BytesPerRow(m_layer.Rect, m_layer.PsdFile.Depth);
        for (int row = 0; row < m_layer.Rect.Height; row++)
        {
          int rowIndex = row * m_layer.Rect.Width;
          rleRowLengths[row] = (short)RleHelper.EncodedRow(dataStream, m_imageData, rowIndex, bytesPerRow);
        }

        // Write RLE row lengths and save
        for (int i = 0; i < rleRowLengths.Length; i++)
        {
          headerWriter.Write((short)rleRowLengths[i]);
        }
        headerStream.Flush();
        this.RleHeader = headerStream.ToArray();
        headerStream.Close();

        // Save compressed data
        dataStream.Flush();
        m_data = dataStream.ToArray();
        dataStream.Close();

        this.Length = 2 + this.RleHeader.Length + m_data.Length;
      }
      else
      {
        m_data = m_imageData;
        this.Length = 2 + m_data.Length;
      }


    }

    internal void SavePixelData(PsdBinaryWriter writer)
    {
      Debug.WriteLine("Channel SavePixelData started at " + writer.BaseStream.Position.ToString(CultureInfo.InvariantCulture));

      writer.Write((short)m_imageCompression);
      if (m_imageCompression == PhotoshopFile.ImageCompression.Rle)
        writer.Write(this.RleHeader);
      writer.Write(m_data);
    }

    //////////////////////////////////////////////////////////////////

    public PsdBinaryReader DataReader
    {
      get
      {
        if (m_data == null)
          return null;

        return new PsdBinaryReader(new System.IO.MemoryStream(this.m_data));
      }
    }
  }
}
